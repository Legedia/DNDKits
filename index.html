<!DOCTYPE html>
<html>
<head>
    <title>Map Generator</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }

        #mapGenerator {
            text-align: center;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #mapCanvas {
            border: 1px solid #ccc;
            margin-top: 10px;
            image-rendering: pixelated; /* Ensures crisp pixels */
        }

        #mapKey {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        .key-item {
            display: flex;
            align-items: center;
            margin: 5px 10px;
        }

        .key-color {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            margin-right: 5px;
        }

        #mapSizeInput {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        #generateButton {
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #generateButton:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div id="mapGenerator">
        <h1>Map Generator</h1>
        <input type="number" id="mapSizeInput" placeholder="Map Size (e.g., 50)" value="50">
        <button id="generateButton" onclick="generateMap(parseInt(document.getElementById('mapSizeInput').value))">Generate Map</button>
        <canvas id="mapCanvas" width="500" height="500"></canvas>
        <div id="mapKey">
            <div class="key-item"><div class="key-color" data-terrain="grassland"></div>Grassland</div>
            <div class="key-item"><div class="key-color" data-terrain="forest"></div>Forest</div>
            <div class="key-item"><div class="key-color" data-terrain="desert"></div>Desert</div>
            <div class="key-item"><div class="key-color" data-terrain="mountain"></div>Mountain</div>
            <div class="key-item"><div class="key-color" data-terrain="rock"></div>Rock</div>
            <div class="key-item"><div class="key-color" data-terrain="water"></div>Water</div>
        </div>
    </div>

    <script>
        // Perlin Noise implementation (from previous responses)
        class PerlinNoise {
            constructor(seed = Math.random()) {
                this.seed = seed;
                this.gradients = {};
            }

            rand(x, y) {
                let n = x + y * 57;
                n = (n << 13) ^ n;
                return Math.abs((1.0 - ((n * (n * n * 15731 + 789221) + this.seed) & 0x7fffffff) / 1073741824.0));
            }

            grad(x, y) {
                const key = `<span class="math-inline">\{x\},</span>{y}`;
                if (this.gradients[key]) {
                    return this.gradients[key];
                }

                const v = Math.random() * 2 * Math.PI;
                const g = [Math.cos(v), Math.sin(v)];
                this.gradients[key] = g;
                return g;
            }

            noise(x, y) {
                const xf = Math.floor(x);
                const yf = Math.floor(y);

                const tl = this.grad(xf, yf);
                const tr = this.grad(xf + 1, yf);
                const bl = this.grad(xf, yf + 1);
                const br = this.grad(xf + 1, yf + 1);

                const tx = x - xf;
                const ty = y - yf;

                const xtl = tl[0] * tx + tl[1] * ty;
                const xtr = tr[0] * (tx - 1) + tr[1] * ty;
                const xbl = bl[0] * tx + bl[1] * (ty - 1);
                const xbr = br[0] * (tx - 1) + br[1] * (ty - 1);

                const u = fade(tx);
                const v = fade(ty);

                const x1 = lerp(xtl, xtr, u);
                const x2 = lerp(xbl, xbr, u);

                return lerp(x1, x2, v);
            }
        }

        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }

        function lerp(a, b, t) {
            return a + t * (b - a);
        }

        function generateMap(mapSize) {
            console.log("generateMap called with mapSize:", mapSize);

            const mapCanvas = document.getElementById('mapCanvas');
            const ctx = mapCanvas.getContext('2d');

            if (!ctx) {
                console.error("Canvas context is null!");
                return;
            }

            // Clear the canvas
            ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);

            // Calculate tile size
            const tileSize = mapCanvas.width / mapSize;
            console.log("tileSize:", tileSize);

            // Generate map data
            const mapData = generateMapData(mapSize);
            console.log("mapData:", mapData);

            // Draw tiles
            drawMap(ctx, mapData, tileSize);

            // Update color key
            updateColorKey();
        }

        function generateMapData(mapSize) {
            const map = [];
            const noise = new PerlinNoise();

            for (let y = 0; y < mapSize; y++) {
                const row = [];
                for (let x = 0; x < mapSize; x++) {
                    const value = noise.noise(x / 10, y / 10, 0);
                    let terrain = 'grassland';

                    if (value > 0.5) {
                        terrain = 'mountain';
                    } else if (value > 0.3) {
                        terrain = 'forest';
                    } else if (value < -0.3) {
                        terrain = 'water';
                    } else if (value < 0) {
                        terrain = 'desert';
                    }

                    row.push(terrain);
                }
                map.push(row);
            }

            return map;
        }

        function drawMap(ctx, mapData, tileSize) {
            console.log("drawMap called with mapData:", mapData, "tileSize:", tileSize);

            if (!ctx) {
                console.error("Canvas context is null in drawMap!");
                return;
            }

            for (let y = 0; y < mapData.length; y++) {
                for (let x = 0; x < mapData[y].length; x++) {
                    const tile = mapData[y][x];
                    let color = '';

                    console.log("tile in drawMap:", tile);

                    switch (tile) {
                        case 'grassland':
                            color = 'green';
                            break;
                        case 'forest':
                            color = 'darkgreen';
                            break;
                        case 'desert':
                            color = 'yellow';
                            break;
                        case 'mountain':
                            color = 'gray';
                            break;
                        case 'rock':
                            color = 'darkgray';
                            break;
                        case 'water':
                            color = 'blue';
                            break;
                        default:
                            color = 'lightgray';
                            break;
                    }

                    console.log("color in drawMap:", color);ctx.fillStyle = color;
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    ctx.strokeStyle = '#ccc';
                    ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }
        }

        function updateColorKey() {
            const keyColors = document.querySelectorAll('#mapKey .key-color');
            keyColors.forEach(keyColor => {
                const terrain = keyColor.dataset.terrain;
                let color = '';

                switch (terrain) {
                    case 'grassland':
                        color = 'green';
                        break;
                    case 'forest':
                        color = 'darkgreen';
                        break;
                    case 'desert':
                        color = 'yellow';
                        break;
                    case 'mountain':
                        color = 'gray';
                        break;
                    case 'rock':
                        color = 'darkgray';
                        break;
                    case 'water':
                        color = 'blue';
                        break;
                    default:
                        color = 'lightgray';
                        break;
                }

                keyColor.style.backgroundColor = color;
            });
        }
    </script>
</body>
</html>